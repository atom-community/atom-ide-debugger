"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _bindObservableAsProps = require("@atom-ide-community/nuclide-commons-ui/bindObservableAsProps");

var React = _interopRequireWildcard(require("react"));

var _rxjsCompatUmdMin = require("rxjs-compat/bundles/rxjs-compat.umd.min.js");

var _Section = require("@atom-ide-community/nuclide-commons-ui/Section");

var _UniversalDisposable = _interopRequireDefault(require("@atom-ide-community/nuclide-commons/UniversalDisposable"));

var _event = require("@atom-ide-community/nuclide-commons/event");

var _expected = require("@atom-ide-community/nuclide-commons/expected");

var _LoadingSpinner = require("@atom-ide-community/nuclide-commons-ui/LoadingSpinner");

var _ExpressionTreeComponent = require("./ExpressionTreeComponent");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const NO_VARIABLES = /*#__PURE__*/React.createElement("div", {
  className: "debugger-expression-value-row"
}, /*#__PURE__*/React.createElement("span", {
  className: "debugger-expression-value-content"
}, "(no variables)"));
const LOADING = /*#__PURE__*/React.createElement("div", {
  className: "debugger-expression-value-row"
}, /*#__PURE__*/React.createElement("span", {
  className: "debugger-expression-value-content"
}, /*#__PURE__*/React.createElement(_LoadingSpinner.LoadingSpinner, {
  size: "MEDIUM"
})));

class ScopesComponent extends React.Component {
  constructor(props) {
    super(props);
    this._disposables = void 0;
    this._expansionStates = void 0;
    this.state = {
      scopes: _expected.Expect.value([]),
      // UX: Local scope names should be expanded by default.
      expandedScopes: new Set(["Local", "Locals"])
    };
    this._expansionStates = new Map();
    this._disposables = new _UniversalDisposable.default();
  }

  componentDidMount() {
    const {
      viewModel
    } = this.props.service;

    this._disposables.add(_rxjsCompatUmdMin.Observable.merge((0, _event.observableFromSubscribeFunction)(viewModel.onDidChangeDebuggerFocus.bind(viewModel)).map(() => false), (0, _event.observableFromSubscribeFunction)(viewModel.onDidChangeExpressionContext.bind(viewModel)).map(() => true)).debounceTime(100).startWith(false).switchMap(forceRefresh => this._getScopes(forceRefresh)).subscribe(scopes => {
      this.setState({
        scopes
      });
    }));
  }

  _getScopes(forceRefresh) {
    const {
      focusedStackFrame
    } = this.props.service.viewModel;

    if (focusedStackFrame == null) {
      return _rxjsCompatUmdMin.Observable.of(_expected.Expect.value([]));
    } else {
      // If refreshing explicitly, don't start with pending because
      // there's no reason to show a spinner in an already-populated
      // scopes tree.
      const result = _rxjsCompatUmdMin.Observable.fromPromise(focusedStackFrame.getScopes(forceRefresh).then(scopes => _expected.Expect.value(scopes), error => _expected.Expect.error(error)));

      return forceRefresh ? result : _rxjsCompatUmdMin.Observable.of(_expected.Expect.pending()).concat(result);
    }
  }

  componentWillUnmount() {
    this._disposables.dispose();
  }

  _renderScopeSection(scope) {
    // Non-local scopes should be collapsed by default since users typically care less about them.
    const expanded = this._isScopeExpanded(scope);

    const ScopeBodyComponent = expanded ? (0, _bindObservableAsProps.bindObservableAsProps)(this._getScopeVariables(scope).map(variables => ({
      variables,
      containerContext: this
    })), ScopeComponent) : () => null;
    return /*#__PURE__*/React.createElement(_Section.Section, {
      key: scope.getId(),
      collapsable: true,
      collapsed: !expanded,
      onChange: isCollapsed => this._setScopeExpanded(scope, !isCollapsed),
      headline: scope.name,
      size: "small"
    }, /*#__PURE__*/React.createElement(ScopeBodyComponent, null));
  }

  _getScopeVariables(scope) {
    return _rxjsCompatUmdMin.Observable.of(_expected.Expect.pending()).concat(_rxjsCompatUmdMin.Observable.fromPromise(scope.getChildren().then(variables => _expected.Expect.value(variables), error => _expected.Expect.error(error))));
  }

  _isScopeExpanded(scope) {
    return this.state.expandedScopes.has(scope.name);
  }

  _setScopeExpanded(scope, expanded) {
    if (expanded === this.state.expandedScopes.has(scope.name)) {
      return;
    } // TODO: (wbinnssmith) T30771435 this setState depends on current state
    // and should use an updater function rather than an object
    // eslint-disable-next-line react/no-access-state-in-setstate


    const expandedScopes = new Set(this.state.expandedScopes);

    if (expanded) {
      expandedScopes.add(scope.name);
    } else {
      expandedScopes.delete(scope.name);
    }

    this.setState({
      expandedScopes
    });
  }

  render() {
    const {
      scopes
    } = this.state;

    if (scopes.isError) {
      return /*#__PURE__*/React.createElement("span", null, "Error fetching scopes: ", scopes.error.toString());
    } else if (scopes.isPending) {
      return LOADING;
    } else if (scopes.value.length === 0) {
      return /*#__PURE__*/React.createElement("span", null, "(no variables)");
    }

    const scopeSections = scopes.value.map(scope => this._renderScopeSection(scope));
    return /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("div", {
      className: "debugger-expression-value-list"
    }, scopeSections));
  }

}

exports.default = ScopesComponent;

class ScopeComponent extends React.Component {
  render() {
    const {
      variables
    } = this.props;

    if (variables.isError) {
      return /*#__PURE__*/React.createElement("div", null, "Error fetching scope variables ", variables.error.toString());
    } else if (variables.isPending) {
      return LOADING;
    } else if (variables.value.length === 0) {
      return NO_VARIABLES;
    } else {
      return variables.value.map(variable => this._renderVariable(variable));
    }
  }

  _renderVariable(expression) {
    return /*#__PURE__*/React.createElement("div", {
      className: "debugger-expression-value-row debugger-scope",
      key: expression.name
    }, /*#__PURE__*/React.createElement("div", {
      className: "debugger-expression-value-content"
    }, /*#__PURE__*/React.createElement(_ExpressionTreeComponent.ExpressionTreeComponent, {
      expression: expression,
      containerContext: this.props.containerContext
    })));
  }

}

module.exports = exports.default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlNjb3Blc0NvbXBvbmVudC5qcyJdLCJuYW1lcyI6WyJOT19WQVJJQUJMRVMiLCJMT0FESU5HIiwiU2NvcGVzQ29tcG9uZW50IiwiUmVhY3QiLCJDb21wb25lbnQiLCJjb25zdHJ1Y3RvciIsInByb3BzIiwiX2Rpc3Bvc2FibGVzIiwiX2V4cGFuc2lvblN0YXRlcyIsInN0YXRlIiwic2NvcGVzIiwiRXhwZWN0IiwidmFsdWUiLCJleHBhbmRlZFNjb3BlcyIsIlNldCIsIk1hcCIsIlVuaXZlcnNhbERpc3Bvc2FibGUiLCJjb21wb25lbnREaWRNb3VudCIsInZpZXdNb2RlbCIsInNlcnZpY2UiLCJhZGQiLCJPYnNlcnZhYmxlIiwibWVyZ2UiLCJvbkRpZENoYW5nZURlYnVnZ2VyRm9jdXMiLCJiaW5kIiwibWFwIiwib25EaWRDaGFuZ2VFeHByZXNzaW9uQ29udGV4dCIsImRlYm91bmNlVGltZSIsInN0YXJ0V2l0aCIsInN3aXRjaE1hcCIsImZvcmNlUmVmcmVzaCIsIl9nZXRTY29wZXMiLCJzdWJzY3JpYmUiLCJzZXRTdGF0ZSIsImZvY3VzZWRTdGFja0ZyYW1lIiwib2YiLCJyZXN1bHQiLCJmcm9tUHJvbWlzZSIsImdldFNjb3BlcyIsInRoZW4iLCJlcnJvciIsInBlbmRpbmciLCJjb25jYXQiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsImRpc3Bvc2UiLCJfcmVuZGVyU2NvcGVTZWN0aW9uIiwic2NvcGUiLCJleHBhbmRlZCIsIl9pc1Njb3BlRXhwYW5kZWQiLCJTY29wZUJvZHlDb21wb25lbnQiLCJfZ2V0U2NvcGVWYXJpYWJsZXMiLCJ2YXJpYWJsZXMiLCJjb250YWluZXJDb250ZXh0IiwiU2NvcGVDb21wb25lbnQiLCJnZXRJZCIsImlzQ29sbGFwc2VkIiwiX3NldFNjb3BlRXhwYW5kZWQiLCJuYW1lIiwiZ2V0Q2hpbGRyZW4iLCJoYXMiLCJkZWxldGUiLCJyZW5kZXIiLCJpc0Vycm9yIiwidG9TdHJpbmciLCJpc1BlbmRpbmciLCJsZW5ndGgiLCJzY29wZVNlY3Rpb25zIiwidmFyaWFibGUiLCJfcmVuZGVyVmFyaWFibGUiLCJleHByZXNzaW9uIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBR0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7O0FBTUEsTUFBTUEsWUFBWSxnQkFDaEI7QUFBSyxFQUFBLFNBQVMsRUFBQztBQUFmLGdCQUNFO0FBQU0sRUFBQSxTQUFTLEVBQUM7QUFBaEIsb0JBREYsQ0FERjtBQU1BLE1BQU1DLE9BQU8sZ0JBQ1g7QUFBSyxFQUFBLFNBQVMsRUFBQztBQUFmLGdCQUNFO0FBQU0sRUFBQSxTQUFTLEVBQUM7QUFBaEIsZ0JBQ0Usb0JBQUMsOEJBQUQ7QUFBZ0IsRUFBQSxJQUFJLEVBQUM7QUFBckIsRUFERixDQURGLENBREY7O0FBYWUsTUFBTUMsZUFBTixTQUE4QkMsS0FBSyxDQUFDQyxTQUFwQyxDQUE0RDtBQUl6RUMsRUFBQUEsV0FBVyxDQUFDQyxLQUFELEVBQWU7QUFDeEIsVUFBTUEsS0FBTjtBQUR3QixTQUgxQkMsWUFHMEI7QUFBQSxTQUYxQkMsZ0JBRTBCO0FBRXhCLFNBQUtDLEtBQUwsR0FBYTtBQUNYQyxNQUFBQSxNQUFNLEVBQUVDLGlCQUFPQyxLQUFQLENBQWEsRUFBYixDQURHO0FBRVg7QUFDQUMsTUFBQUEsY0FBYyxFQUFFLElBQUlDLEdBQUosQ0FBUSxDQUFDLE9BQUQsRUFBVSxRQUFWLENBQVI7QUFITCxLQUFiO0FBS0EsU0FBS04sZ0JBQUwsR0FBd0IsSUFBSU8sR0FBSixFQUF4QjtBQUNBLFNBQUtSLFlBQUwsR0FBb0IsSUFBSVMsNEJBQUosRUFBcEI7QUFDRDs7QUFFREMsRUFBQUEsaUJBQWlCLEdBQVM7QUFDeEIsVUFBTTtBQUFFQyxNQUFBQTtBQUFGLFFBQWdCLEtBQUtaLEtBQUwsQ0FBV2EsT0FBakM7O0FBQ0EsU0FBS1osWUFBTCxDQUFrQmEsR0FBbEIsQ0FDRUMsNkJBQVdDLEtBQVgsQ0FDRSw0Q0FBZ0NKLFNBQVMsQ0FBQ0ssd0JBQVYsQ0FBbUNDLElBQW5DLENBQXdDTixTQUF4QyxDQUFoQyxFQUFvRk8sR0FBcEYsQ0FBd0YsTUFBTSxLQUE5RixDQURGLEVBRUUsNENBQWdDUCxTQUFTLENBQUNRLDRCQUFWLENBQXVDRixJQUF2QyxDQUE0Q04sU0FBNUMsQ0FBaEMsRUFBd0ZPLEdBQXhGLENBQTRGLE1BQU0sSUFBbEcsQ0FGRixFQUlHRSxZQUpILENBSWdCLEdBSmhCLEVBS0dDLFNBTEgsQ0FLYSxLQUxiLEVBTUdDLFNBTkgsQ0FNY0MsWUFBRCxJQUEyQixLQUFLQyxVQUFMLENBQWdCRCxZQUFoQixDQU54QyxFQU9HRSxTQVBILENBT2N0QixNQUFELElBQVk7QUFDckIsV0FBS3VCLFFBQUwsQ0FBYztBQUFFdkIsUUFBQUE7QUFBRixPQUFkO0FBQ0QsS0FUSCxDQURGO0FBWUQ7O0FBRURxQixFQUFBQSxVQUFVLENBQUNELFlBQUQsRUFBNkQ7QUFDckUsVUFBTTtBQUFFSSxNQUFBQTtBQUFGLFFBQXdCLEtBQUs1QixLQUFMLENBQVdhLE9BQVgsQ0FBbUJELFNBQWpEOztBQUNBLFFBQUlnQixpQkFBaUIsSUFBSSxJQUF6QixFQUErQjtBQUM3QixhQUFPYiw2QkFBV2MsRUFBWCxDQUFjeEIsaUJBQU9DLEtBQVAsQ0FBYSxFQUFiLENBQWQsQ0FBUDtBQUNELEtBRkQsTUFFTztBQUNMO0FBQ0E7QUFDQTtBQUNBLFlBQU13QixNQUFNLEdBQUdmLDZCQUFXZ0IsV0FBWCxDQUNiSCxpQkFBaUIsQ0FBQ0ksU0FBbEIsQ0FBNEJSLFlBQTVCLEVBQTBDUyxJQUExQyxDQUNHN0IsTUFBRCxJQUFZQyxpQkFBT0MsS0FBUCxDQUFhRixNQUFiLENBRGQsRUFFRzhCLEtBQUQsSUFBVzdCLGlCQUFPNkIsS0FBUCxDQUFhQSxLQUFiLENBRmIsQ0FEYSxDQUFmOztBQU1BLGFBQU9WLFlBQVksR0FBR00sTUFBSCxHQUFZZiw2QkFBV2MsRUFBWCxDQUFjeEIsaUJBQU84QixPQUFQLEVBQWQsRUFBZ0NDLE1BQWhDLENBQXVDTixNQUF2QyxDQUEvQjtBQUNEO0FBQ0Y7O0FBRURPLEVBQUFBLG9CQUFvQixHQUFTO0FBQzNCLFNBQUtwQyxZQUFMLENBQWtCcUMsT0FBbEI7QUFDRDs7QUFFREMsRUFBQUEsbUJBQW1CLENBQUNDLEtBQUQsRUFBcUM7QUFDdEQ7QUFDQSxVQUFNQyxRQUFRLEdBQUcsS0FBS0MsZ0JBQUwsQ0FBc0JGLEtBQXRCLENBQWpCOztBQUNBLFVBQU1HLGtCQUFrQixHQUFHRixRQUFRLEdBQy9CLGtEQUNFLEtBQUtHLGtCQUFMLENBQXdCSixLQUF4QixFQUErQnJCLEdBQS9CLENBQW9DMEIsU0FBRCxLQUFnQjtBQUNqREEsTUFBQUEsU0FEaUQ7QUFFakRDLE1BQUFBLGdCQUFnQixFQUFFO0FBRitCLEtBQWhCLENBQW5DLENBREYsRUFLRUMsY0FMRixDQUQrQixHQVEvQixNQUFNLElBUlY7QUFVQSx3QkFDRSxvQkFBQyxnQkFBRDtBQUNFLE1BQUEsR0FBRyxFQUFFUCxLQUFLLENBQUNRLEtBQU4sRUFEUDtBQUVFLE1BQUEsV0FBVyxFQUFFLElBRmY7QUFHRSxNQUFBLFNBQVMsRUFBRSxDQUFDUCxRQUhkO0FBSUUsTUFBQSxRQUFRLEVBQUdRLFdBQUQsSUFBaUIsS0FBS0MsaUJBQUwsQ0FBdUJWLEtBQXZCLEVBQThCLENBQUNTLFdBQS9CLENBSjdCO0FBS0UsTUFBQSxRQUFRLEVBQUVULEtBQUssQ0FBQ1csSUFMbEI7QUFNRSxNQUFBLElBQUksRUFBQztBQU5QLG9CQVFFLG9CQUFDLGtCQUFELE9BUkYsQ0FERjtBQVlEOztBQUVEUCxFQUFBQSxrQkFBa0IsQ0FBQ0osS0FBRCxFQUF3RDtBQUN4RSxXQUFPekIsNkJBQVdjLEVBQVgsQ0FBY3hCLGlCQUFPOEIsT0FBUCxFQUFkLEVBQWdDQyxNQUFoQyxDQUNMckIsNkJBQVdnQixXQUFYLENBQ0VTLEtBQUssQ0FBQ1ksV0FBTixHQUFvQm5CLElBQXBCLENBQ0dZLFNBQUQsSUFBZXhDLGlCQUFPQyxLQUFQLENBQWF1QyxTQUFiLENBRGpCLEVBRUdYLEtBQUQsSUFBVzdCLGlCQUFPNkIsS0FBUCxDQUFhQSxLQUFiLENBRmIsQ0FERixDQURLLENBQVA7QUFRRDs7QUFFRFEsRUFBQUEsZ0JBQWdCLENBQUNGLEtBQUQsRUFBeUI7QUFDdkMsV0FBTyxLQUFLckMsS0FBTCxDQUFXSSxjQUFYLENBQTBCOEMsR0FBMUIsQ0FBOEJiLEtBQUssQ0FBQ1csSUFBcEMsQ0FBUDtBQUNEOztBQUVERCxFQUFBQSxpQkFBaUIsQ0FBQ1YsS0FBRCxFQUFnQkMsUUFBaEIsRUFBeUM7QUFDeEQsUUFBSUEsUUFBUSxLQUFLLEtBQUt0QyxLQUFMLENBQVdJLGNBQVgsQ0FBMEI4QyxHQUExQixDQUE4QmIsS0FBSyxDQUFDVyxJQUFwQyxDQUFqQixFQUE0RDtBQUMxRDtBQUNELEtBSHVELENBSXhEO0FBQ0E7QUFDQTs7O0FBQ0EsVUFBTTVDLGNBQWMsR0FBRyxJQUFJQyxHQUFKLENBQVEsS0FBS0wsS0FBTCxDQUFXSSxjQUFuQixDQUF2Qjs7QUFDQSxRQUFJa0MsUUFBSixFQUFjO0FBQ1psQyxNQUFBQSxjQUFjLENBQUNPLEdBQWYsQ0FBbUIwQixLQUFLLENBQUNXLElBQXpCO0FBQ0QsS0FGRCxNQUVPO0FBQ0w1QyxNQUFBQSxjQUFjLENBQUMrQyxNQUFmLENBQXNCZCxLQUFLLENBQUNXLElBQTVCO0FBQ0Q7O0FBQ0QsU0FBS3hCLFFBQUwsQ0FBYztBQUFFcEIsTUFBQUE7QUFBRixLQUFkO0FBQ0Q7O0FBRURnRCxFQUFBQSxNQUFNLEdBQWU7QUFDbkIsVUFBTTtBQUFFbkQsTUFBQUE7QUFBRixRQUFhLEtBQUtELEtBQXhCOztBQUNBLFFBQUlDLE1BQU0sQ0FBQ29ELE9BQVgsRUFBb0I7QUFDbEIsMEJBQU8sNkRBQThCcEQsTUFBTSxDQUFDOEIsS0FBUCxDQUFhdUIsUUFBYixFQUE5QixDQUFQO0FBQ0QsS0FGRCxNQUVPLElBQUlyRCxNQUFNLENBQUNzRCxTQUFYLEVBQXNCO0FBQzNCLGFBQU8vRCxPQUFQO0FBQ0QsS0FGTSxNQUVBLElBQUlTLE1BQU0sQ0FBQ0UsS0FBUCxDQUFhcUQsTUFBYixLQUF3QixDQUE1QixFQUErQjtBQUNwQywwQkFBTyxtREFBUDtBQUNEOztBQUNELFVBQU1DLGFBQWEsR0FBR3hELE1BQU0sQ0FBQ0UsS0FBUCxDQUFhYSxHQUFiLENBQWtCcUIsS0FBRCxJQUFXLEtBQUtELG1CQUFMLENBQXlCQyxLQUF6QixDQUE1QixDQUF0QjtBQUNBLHdCQUNFLDhDQUNFO0FBQUssTUFBQSxTQUFTLEVBQUM7QUFBZixPQUFpRG9CLGFBQWpELENBREYsQ0FERjtBQUtEOztBQTlId0U7Ozs7QUFzSTNFLE1BQU1iLGNBQU4sU0FBNkJsRCxLQUFLLENBQUNDLFNBQW5DLENBQXlEO0FBQ3ZEeUQsRUFBQUEsTUFBTSxHQUFHO0FBQ1AsVUFBTTtBQUFFVixNQUFBQTtBQUFGLFFBQWdCLEtBQUs3QyxLQUEzQjs7QUFDQSxRQUFJNkMsU0FBUyxDQUFDVyxPQUFkLEVBQXVCO0FBQ3JCLDBCQUFPLG9FQUFxQ1gsU0FBUyxDQUFDWCxLQUFWLENBQWdCdUIsUUFBaEIsRUFBckMsQ0FBUDtBQUNELEtBRkQsTUFFTyxJQUFJWixTQUFTLENBQUNhLFNBQWQsRUFBeUI7QUFDOUIsYUFBTy9ELE9BQVA7QUFDRCxLQUZNLE1BRUEsSUFBSWtELFNBQVMsQ0FBQ3ZDLEtBQVYsQ0FBZ0JxRCxNQUFoQixLQUEyQixDQUEvQixFQUFrQztBQUN2QyxhQUFPakUsWUFBUDtBQUNELEtBRk0sTUFFQTtBQUNMLGFBQU9tRCxTQUFTLENBQUN2QyxLQUFWLENBQWdCYSxHQUFoQixDQUFxQjBDLFFBQUQsSUFBYyxLQUFLQyxlQUFMLENBQXFCRCxRQUFyQixDQUFsQyxDQUFQO0FBQ0Q7QUFDRjs7QUFFREMsRUFBQUEsZUFBZSxDQUFDQyxVQUFELEVBQTZDO0FBQzFELHdCQUNFO0FBQUssTUFBQSxTQUFTLEVBQUMsOENBQWY7QUFBOEQsTUFBQSxHQUFHLEVBQUVBLFVBQVUsQ0FBQ1o7QUFBOUUsb0JBQ0U7QUFBSyxNQUFBLFNBQVMsRUFBQztBQUFmLG9CQUNFLG9CQUFDLGdEQUFEO0FBQXlCLE1BQUEsVUFBVSxFQUFFWSxVQUFyQztBQUFpRCxNQUFBLGdCQUFnQixFQUFFLEtBQUsvRCxLQUFMLENBQVc4QztBQUE5RSxNQURGLENBREYsQ0FERjtBQU9EOztBQXRCc0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IElEZWJ1Z1NlcnZpY2UsIElTY29wZSwgSVZhcmlhYmxlIH0gZnJvbSBcIi4uL3R5cGVzXCJcclxuaW1wb3J0IHR5cGUgeyBFeHBlY3RlZCB9IGZyb20gXCJAYXRvbS1pZGUtY29tbXVuaXR5L251Y2xpZGUtY29tbW9ucy9leHBlY3RlZFwiXHJcblxyXG5pbXBvcnQgeyBiaW5kT2JzZXJ2YWJsZUFzUHJvcHMgfSBmcm9tIFwiQGF0b20taWRlLWNvbW11bml0eS9udWNsaWRlLWNvbW1vbnMtdWkvYmluZE9ic2VydmFibGVBc1Byb3BzXCJcclxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCJcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gXCJyeGpzLWNvbXBhdC9idW5kbGVzL3J4anMtY29tcGF0LnVtZC5taW4uanNcIlxyXG5pbXBvcnQgeyBTZWN0aW9uIH0gZnJvbSBcIkBhdG9tLWlkZS1jb21tdW5pdHkvbnVjbGlkZS1jb21tb25zLXVpL1NlY3Rpb25cIlxyXG5pbXBvcnQgVW5pdmVyc2FsRGlzcG9zYWJsZSBmcm9tIFwiQGF0b20taWRlLWNvbW11bml0eS9udWNsaWRlLWNvbW1vbnMvVW5pdmVyc2FsRGlzcG9zYWJsZVwiXHJcbmltcG9ydCB7IG9ic2VydmFibGVGcm9tU3Vic2NyaWJlRnVuY3Rpb24gfSBmcm9tIFwiQGF0b20taWRlLWNvbW11bml0eS9udWNsaWRlLWNvbW1vbnMvZXZlbnRcIlxyXG5pbXBvcnQgeyBFeHBlY3QgfSBmcm9tIFwiQGF0b20taWRlLWNvbW11bml0eS9udWNsaWRlLWNvbW1vbnMvZXhwZWN0ZWRcIlxyXG5pbXBvcnQgeyBMb2FkaW5nU3Bpbm5lciB9IGZyb20gXCJAYXRvbS1pZGUtY29tbXVuaXR5L251Y2xpZGUtY29tbW9ucy11aS9Mb2FkaW5nU3Bpbm5lclwiXHJcbmltcG9ydCB7IEV4cHJlc3Npb25UcmVlQ29tcG9uZW50IH0gZnJvbSBcIi4vRXhwcmVzc2lvblRyZWVDb21wb25lbnRcIlxyXG5cclxudHlwZSBQcm9wcyA9IHtcclxuICArc2VydmljZTogSURlYnVnU2VydmljZSxcclxufVxyXG5cclxuY29uc3QgTk9fVkFSSUFCTEVTID0gKFxyXG4gIDxkaXYgY2xhc3NOYW1lPVwiZGVidWdnZXItZXhwcmVzc2lvbi12YWx1ZS1yb3dcIj5cclxuICAgIDxzcGFuIGNsYXNzTmFtZT1cImRlYnVnZ2VyLWV4cHJlc3Npb24tdmFsdWUtY29udGVudFwiPihubyB2YXJpYWJsZXMpPC9zcGFuPlxyXG4gIDwvZGl2PlxyXG4pXHJcblxyXG5jb25zdCBMT0FESU5HID0gKFxyXG4gIDxkaXYgY2xhc3NOYW1lPVwiZGVidWdnZXItZXhwcmVzc2lvbi12YWx1ZS1yb3dcIj5cclxuICAgIDxzcGFuIGNsYXNzTmFtZT1cImRlYnVnZ2VyLWV4cHJlc3Npb24tdmFsdWUtY29udGVudFwiPlxyXG4gICAgICA8TG9hZGluZ1NwaW5uZXIgc2l6ZT1cIk1FRElVTVwiIC8+XHJcbiAgICA8L3NwYW4+XHJcbiAgPC9kaXY+XHJcbilcclxuXHJcbnR5cGUgU3RhdGUgPSB7XHJcbiAgc2NvcGVzOiBFeHBlY3RlZDxBcnJheTxJU2NvcGU+PixcclxuICBleHBhbmRlZFNjb3BlczogU2V0PHN0cmluZz4sXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjb3Blc0NvbXBvbmVudCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxQcm9wcywgU3RhdGU+IHtcclxuICBfZGlzcG9zYWJsZXM6IFVuaXZlcnNhbERpc3Bvc2FibGVcclxuICBfZXhwYW5zaW9uU3RhdGVzOiBNYXA8c3RyaW5nIC8qIGV4cHJlc3Npb24gKi8sIE9iamVjdCAvKiB1bmlxdWUgcmVmZXJlbmNlIGZvciBleHByZXNzaW9uICovPlxyXG5cclxuICBjb25zdHJ1Y3Rvcihwcm9wczogUHJvcHMpIHtcclxuICAgIHN1cGVyKHByb3BzKVxyXG4gICAgdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgc2NvcGVzOiBFeHBlY3QudmFsdWUoW10pLFxyXG4gICAgICAvLyBVWDogTG9jYWwgc2NvcGUgbmFtZXMgc2hvdWxkIGJlIGV4cGFuZGVkIGJ5IGRlZmF1bHQuXHJcbiAgICAgIGV4cGFuZGVkU2NvcGVzOiBuZXcgU2V0KFtcIkxvY2FsXCIsIFwiTG9jYWxzXCJdKSxcclxuICAgIH1cclxuICAgIHRoaXMuX2V4cGFuc2lvblN0YXRlcyA9IG5ldyBNYXAoKVxyXG4gICAgdGhpcy5fZGlzcG9zYWJsZXMgPSBuZXcgVW5pdmVyc2FsRGlzcG9zYWJsZSgpXHJcbiAgfVxyXG5cclxuICBjb21wb25lbnREaWRNb3VudCgpOiB2b2lkIHtcclxuICAgIGNvbnN0IHsgdmlld01vZGVsIH0gPSB0aGlzLnByb3BzLnNlcnZpY2VcclxuICAgIHRoaXMuX2Rpc3Bvc2FibGVzLmFkZChcclxuICAgICAgT2JzZXJ2YWJsZS5tZXJnZShcclxuICAgICAgICBvYnNlcnZhYmxlRnJvbVN1YnNjcmliZUZ1bmN0aW9uKHZpZXdNb2RlbC5vbkRpZENoYW5nZURlYnVnZ2VyRm9jdXMuYmluZCh2aWV3TW9kZWwpKS5tYXAoKCkgPT4gZmFsc2UpLFxyXG4gICAgICAgIG9ic2VydmFibGVGcm9tU3Vic2NyaWJlRnVuY3Rpb24odmlld01vZGVsLm9uRGlkQ2hhbmdlRXhwcmVzc2lvbkNvbnRleHQuYmluZCh2aWV3TW9kZWwpKS5tYXAoKCkgPT4gdHJ1ZSlcclxuICAgICAgKVxyXG4gICAgICAgIC5kZWJvdW5jZVRpbWUoMTAwKVxyXG4gICAgICAgIC5zdGFydFdpdGgoZmFsc2UpXHJcbiAgICAgICAgLnN3aXRjaE1hcCgoZm9yY2VSZWZyZXNoOiBib29sZWFuKSA9PiB0aGlzLl9nZXRTY29wZXMoZm9yY2VSZWZyZXNoKSlcclxuICAgICAgICAuc3Vic2NyaWJlKChzY29wZXMpID0+IHtcclxuICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBzY29wZXMgfSlcclxuICAgICAgICB9KVxyXG4gICAgKVxyXG4gIH1cclxuXHJcbiAgX2dldFNjb3Blcyhmb3JjZVJlZnJlc2g6IGJvb2xlYW4pOiBPYnNlcnZhYmxlPEV4cGVjdGVkPEFycmF5PElTY29wZT4+PiB7XHJcbiAgICBjb25zdCB7IGZvY3VzZWRTdGFja0ZyYW1lIH0gPSB0aGlzLnByb3BzLnNlcnZpY2Uudmlld01vZGVsXHJcbiAgICBpZiAoZm9jdXNlZFN0YWNrRnJhbWUgPT0gbnVsbCkge1xyXG4gICAgICByZXR1cm4gT2JzZXJ2YWJsZS5vZihFeHBlY3QudmFsdWUoW10pKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gSWYgcmVmcmVzaGluZyBleHBsaWNpdGx5LCBkb24ndCBzdGFydCB3aXRoIHBlbmRpbmcgYmVjYXVzZVxyXG4gICAgICAvLyB0aGVyZSdzIG5vIHJlYXNvbiB0byBzaG93IGEgc3Bpbm5lciBpbiBhbiBhbHJlYWR5LXBvcHVsYXRlZFxyXG4gICAgICAvLyBzY29wZXMgdHJlZS5cclxuICAgICAgY29uc3QgcmVzdWx0ID0gT2JzZXJ2YWJsZS5mcm9tUHJvbWlzZShcclxuICAgICAgICBmb2N1c2VkU3RhY2tGcmFtZS5nZXRTY29wZXMoZm9yY2VSZWZyZXNoKS50aGVuKFxyXG4gICAgICAgICAgKHNjb3BlcykgPT4gRXhwZWN0LnZhbHVlKHNjb3BlcyksXHJcbiAgICAgICAgICAoZXJyb3IpID0+IEV4cGVjdC5lcnJvcihlcnJvcilcclxuICAgICAgICApXHJcbiAgICAgIClcclxuICAgICAgcmV0dXJuIGZvcmNlUmVmcmVzaCA/IHJlc3VsdCA6IE9ic2VydmFibGUub2YoRXhwZWN0LnBlbmRpbmcoKSkuY29uY2F0KHJlc3VsdClcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCk6IHZvaWQge1xyXG4gICAgdGhpcy5fZGlzcG9zYWJsZXMuZGlzcG9zZSgpXHJcbiAgfVxyXG5cclxuICBfcmVuZGVyU2NvcGVTZWN0aW9uKHNjb3BlOiBJU2NvcGUpOiA/UmVhY3QuRWxlbWVudDxhbnk+IHtcclxuICAgIC8vIE5vbi1sb2NhbCBzY29wZXMgc2hvdWxkIGJlIGNvbGxhcHNlZCBieSBkZWZhdWx0IHNpbmNlIHVzZXJzIHR5cGljYWxseSBjYXJlIGxlc3MgYWJvdXQgdGhlbS5cclxuICAgIGNvbnN0IGV4cGFuZGVkID0gdGhpcy5faXNTY29wZUV4cGFuZGVkKHNjb3BlKVxyXG4gICAgY29uc3QgU2NvcGVCb2R5Q29tcG9uZW50ID0gZXhwYW5kZWRcclxuICAgICAgPyBiaW5kT2JzZXJ2YWJsZUFzUHJvcHMoXHJcbiAgICAgICAgICB0aGlzLl9nZXRTY29wZVZhcmlhYmxlcyhzY29wZSkubWFwKCh2YXJpYWJsZXMpID0+ICh7XHJcbiAgICAgICAgICAgIHZhcmlhYmxlcyxcclxuICAgICAgICAgICAgY29udGFpbmVyQ29udGV4dDogdGhpcyxcclxuICAgICAgICAgIH0pKSxcclxuICAgICAgICAgIFNjb3BlQ29tcG9uZW50XHJcbiAgICAgICAgKVxyXG4gICAgICA6ICgpID0+IG51bGxcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICA8U2VjdGlvblxyXG4gICAgICAgIGtleT17c2NvcGUuZ2V0SWQoKX1cclxuICAgICAgICBjb2xsYXBzYWJsZT17dHJ1ZX1cclxuICAgICAgICBjb2xsYXBzZWQ9eyFleHBhbmRlZH1cclxuICAgICAgICBvbkNoYW5nZT17KGlzQ29sbGFwc2VkKSA9PiB0aGlzLl9zZXRTY29wZUV4cGFuZGVkKHNjb3BlLCAhaXNDb2xsYXBzZWQpfVxyXG4gICAgICAgIGhlYWRsaW5lPXtzY29wZS5uYW1lfVxyXG4gICAgICAgIHNpemU9XCJzbWFsbFwiXHJcbiAgICAgID5cclxuICAgICAgICA8U2NvcGVCb2R5Q29tcG9uZW50IC8+XHJcbiAgICAgIDwvU2VjdGlvbj5cclxuICAgIClcclxuICB9XHJcblxyXG4gIF9nZXRTY29wZVZhcmlhYmxlcyhzY29wZTogSVNjb3BlKTogT2JzZXJ2YWJsZTxFeHBlY3RlZDxBcnJheTxJVmFyaWFibGU+Pj4ge1xyXG4gICAgcmV0dXJuIE9ic2VydmFibGUub2YoRXhwZWN0LnBlbmRpbmcoKSkuY29uY2F0KFxyXG4gICAgICBPYnNlcnZhYmxlLmZyb21Qcm9taXNlKFxyXG4gICAgICAgIHNjb3BlLmdldENoaWxkcmVuKCkudGhlbihcclxuICAgICAgICAgICh2YXJpYWJsZXMpID0+IEV4cGVjdC52YWx1ZSh2YXJpYWJsZXMpLFxyXG4gICAgICAgICAgKGVycm9yKSA9PiBFeHBlY3QuZXJyb3IoZXJyb3IpXHJcbiAgICAgICAgKVxyXG4gICAgICApXHJcbiAgICApXHJcbiAgfVxyXG5cclxuICBfaXNTY29wZUV4cGFuZGVkKHNjb3BlOiBJU2NvcGUpOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzLnN0YXRlLmV4cGFuZGVkU2NvcGVzLmhhcyhzY29wZS5uYW1lKVxyXG4gIH1cclxuXHJcbiAgX3NldFNjb3BlRXhwYW5kZWQoc2NvcGU6IElTY29wZSwgZXhwYW5kZWQ6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgIGlmIChleHBhbmRlZCA9PT0gdGhpcy5zdGF0ZS5leHBhbmRlZFNjb3Blcy5oYXMoc2NvcGUubmFtZSkpIHtcclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcbiAgICAvLyBUT0RPOiAod2Jpbm5zc21pdGgpIFQzMDc3MTQzNSB0aGlzIHNldFN0YXRlIGRlcGVuZHMgb24gY3VycmVudCBzdGF0ZVxyXG4gICAgLy8gYW5kIHNob3VsZCB1c2UgYW4gdXBkYXRlciBmdW5jdGlvbiByYXRoZXIgdGhhbiBhbiBvYmplY3RcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9uby1hY2Nlc3Mtc3RhdGUtaW4tc2V0c3RhdGVcclxuICAgIGNvbnN0IGV4cGFuZGVkU2NvcGVzID0gbmV3IFNldCh0aGlzLnN0YXRlLmV4cGFuZGVkU2NvcGVzKVxyXG4gICAgaWYgKGV4cGFuZGVkKSB7XHJcbiAgICAgIGV4cGFuZGVkU2NvcGVzLmFkZChzY29wZS5uYW1lKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZXhwYW5kZWRTY29wZXMuZGVsZXRlKHNjb3BlLm5hbWUpXHJcbiAgICB9XHJcbiAgICB0aGlzLnNldFN0YXRlKHsgZXhwYW5kZWRTY29wZXMgfSlcclxuICB9XHJcblxyXG4gIHJlbmRlcigpOiBSZWFjdC5Ob2RlIHtcclxuICAgIGNvbnN0IHsgc2NvcGVzIH0gPSB0aGlzLnN0YXRlXHJcbiAgICBpZiAoc2NvcGVzLmlzRXJyb3IpIHtcclxuICAgICAgcmV0dXJuIDxzcGFuPkVycm9yIGZldGNoaW5nIHNjb3Blczoge3Njb3Blcy5lcnJvci50b1N0cmluZygpfTwvc3Bhbj5cclxuICAgIH0gZWxzZSBpZiAoc2NvcGVzLmlzUGVuZGluZykge1xyXG4gICAgICByZXR1cm4gTE9BRElOR1xyXG4gICAgfSBlbHNlIGlmIChzY29wZXMudmFsdWUubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHJldHVybiA8c3Bhbj4obm8gdmFyaWFibGVzKTwvc3Bhbj5cclxuICAgIH1cclxuICAgIGNvbnN0IHNjb3BlU2VjdGlvbnMgPSBzY29wZXMudmFsdWUubWFwKChzY29wZSkgPT4gdGhpcy5fcmVuZGVyU2NvcGVTZWN0aW9uKHNjb3BlKSlcclxuICAgIHJldHVybiAoXHJcbiAgICAgIDxkaXY+XHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJkZWJ1Z2dlci1leHByZXNzaW9uLXZhbHVlLWxpc3RcIj57c2NvcGVTZWN0aW9uc308L2Rpdj5cclxuICAgICAgPC9kaXY+XHJcbiAgICApXHJcbiAgfVxyXG59XHJcblxyXG50eXBlIFNjb3BlUHJvcHMgPSB7XHJcbiAgdmFyaWFibGVzOiBFeHBlY3RlZDxBcnJheTxJVmFyaWFibGU+PixcclxuICBjb250YWluZXJDb250ZXh0OiBPYmplY3QsXHJcbn1cclxuXHJcbmNsYXNzIFNjb3BlQ29tcG9uZW50IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFNjb3BlUHJvcHM+IHtcclxuICByZW5kZXIoKSB7XHJcbiAgICBjb25zdCB7IHZhcmlhYmxlcyB9ID0gdGhpcy5wcm9wc1xyXG4gICAgaWYgKHZhcmlhYmxlcy5pc0Vycm9yKSB7XHJcbiAgICAgIHJldHVybiA8ZGl2PkVycm9yIGZldGNoaW5nIHNjb3BlIHZhcmlhYmxlcyB7dmFyaWFibGVzLmVycm9yLnRvU3RyaW5nKCl9PC9kaXY+XHJcbiAgICB9IGVsc2UgaWYgKHZhcmlhYmxlcy5pc1BlbmRpbmcpIHtcclxuICAgICAgcmV0dXJuIExPQURJTkdcclxuICAgIH0gZWxzZSBpZiAodmFyaWFibGVzLnZhbHVlLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gTk9fVkFSSUFCTEVTXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gdmFyaWFibGVzLnZhbHVlLm1hcCgodmFyaWFibGUpID0+IHRoaXMuX3JlbmRlclZhcmlhYmxlKHZhcmlhYmxlKSlcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9yZW5kZXJWYXJpYWJsZShleHByZXNzaW9uOiBJVmFyaWFibGUpOiA/UmVhY3QuRWxlbWVudDxhbnk+IHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZGVidWdnZXItZXhwcmVzc2lvbi12YWx1ZS1yb3cgZGVidWdnZXItc2NvcGVcIiBrZXk9e2V4cHJlc3Npb24ubmFtZX0+XHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJkZWJ1Z2dlci1leHByZXNzaW9uLXZhbHVlLWNvbnRlbnRcIj5cclxuICAgICAgICAgIDxFeHByZXNzaW9uVHJlZUNvbXBvbmVudCBleHByZXNzaW9uPXtleHByZXNzaW9ufSBjb250YWluZXJDb250ZXh0PXt0aGlzLnByb3BzLmNvbnRhaW5lckNvbnRleHR9IC8+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgKVxyXG4gIH1cclxufVxyXG4iXX0=