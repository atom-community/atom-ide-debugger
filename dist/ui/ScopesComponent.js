"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _bindObservableAsProps = require("@atom-ide-community/nuclide-commons-ui/bindObservableAsProps");

var React = _interopRequireWildcard(require("react"));

var _rxjsCompatUmdMin = require("rxjs-compat/bundles/rxjs-compat.umd.min.js");

var _Section = require("@atom-ide-community/nuclide-commons-ui/Section");

var _UniversalDisposable = _interopRequireDefault(require("@atom-ide-community/nuclide-commons/UniversalDisposable"));

var _event = require("@atom-ide-community/nuclide-commons/event");

var _expected = require("@atom-ide-community/nuclide-commons/expected");

var _LoadingSpinner = require("@atom-ide-community/nuclide-commons-ui/LoadingSpinner");

var _ExpressionTreeComponent = require("./ExpressionTreeComponent");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const NO_VARIABLES = /*#__PURE__*/React.createElement("div", {
  className: "debugger-expression-value-row"
}, /*#__PURE__*/React.createElement("span", {
  className: "debugger-expression-value-content"
}, "(no variables)"));
const LOADING = /*#__PURE__*/React.createElement("div", {
  className: "debugger-expression-value-row"
}, /*#__PURE__*/React.createElement("span", {
  className: "debugger-expression-value-content"
}, /*#__PURE__*/React.createElement(_LoadingSpinner.LoadingSpinner, {
  size: "MEDIUM"
})));

class ScopesComponent extends React.Component {
  constructor(props) {
    super(props);
    this._disposables = void 0;
    this._expansionStates = void 0;
    this.state = {
      scopes: _expected.Expect.value([]),
      // UX: Local scope names should be expanded by default.
      expandedScopes: new Set(["Local", "Locals"])
    };
    this._expansionStates = new Map();
    this._disposables = new _UniversalDisposable.default();
  }

  componentDidMount() {
    const {
      viewModel
    } = this.props.service;

    this._disposables.add(_rxjsCompatUmdMin.Observable.merge((0, _event.observableFromSubscribeFunction)(viewModel.onDidChangeDebuggerFocus.bind(viewModel)).map(() => false), (0, _event.observableFromSubscribeFunction)(viewModel.onDidChangeExpressionContext.bind(viewModel)).map(() => true)).debounceTime(100).startWith(false).switchMap(forceRefresh => this._getScopes(forceRefresh)).subscribe(scopes => {
      this.setState({
        scopes
      });
    }));
  }

  _getScopes(forceRefresh) {
    const {
      focusedStackFrame
    } = this.props.service.viewModel;

    if (focusedStackFrame == null) {
      return _rxjsCompatUmdMin.Observable.of(_expected.Expect.value([]));
    } else {
      // If refreshing explicitly, don't start with pending because
      // there's no reason to show a spinner in an already-populated
      // scopes tree.
      const result = _rxjsCompatUmdMin.Observable.fromPromise(focusedStackFrame.getScopes(forceRefresh).then(scopes => _expected.Expect.value(scopes), error => _expected.Expect.error(error)));

      return forceRefresh ? result : _rxjsCompatUmdMin.Observable.of(_expected.Expect.pending()).concat(result);
    }
  }

  componentWillUnmount() {
    this._disposables.dispose();
  }

  _renderScopeSection(scope) {
    // Non-local scopes should be collapsed by default since users typically care less about them.
    const expanded = this._isScopeExpanded(scope);

    const ScopeBodyComponent = expanded ? (0, _bindObservableAsProps.bindObservableAsProps)(this._getScopeVariables(scope).map(variables => ({
      variables,
      containerContext: this
    })), ScopeComponent) : () => null;
    return /*#__PURE__*/React.createElement(_Section.Section, {
      key: scope.getId(),
      collapsable: true,
      collapsed: !expanded,
      onChange: isCollapsed => this._setScopeExpanded(scope, !isCollapsed),
      headline: scope.name,
      size: "small"
    }, /*#__PURE__*/React.createElement(ScopeBodyComponent, null));
  }

  _getScopeVariables(scope) {
    return _rxjsCompatUmdMin.Observable.of(_expected.Expect.pending()).concat(_rxjsCompatUmdMin.Observable.fromPromise(scope.getChildren().then(variables => _expected.Expect.value(variables), error => _expected.Expect.error(error))));
  }

  _isScopeExpanded(scope) {
    return this.state.expandedScopes.has(scope.name);
  }

  _setScopeExpanded(scope, expanded) {
    if (expanded === this.state.expandedScopes.has(scope.name)) {
      return;
    } // TODO: (wbinnssmith) T30771435 this setState depends on current state
    // and should use an updater function rather than an object
    // eslint-disable-next-line react/no-access-state-in-setstate


    const expandedScopes = new Set(this.state.expandedScopes);

    if (expanded) {
      expandedScopes.add(scope.name);
    } else {
      expandedScopes.delete(scope.name);
    }

    this.setState({
      expandedScopes
    });
  }

  render() {
    const {
      scopes
    } = this.state;

    if (scopes.isError) {
      return /*#__PURE__*/React.createElement("span", null, "Error fetching scopes: ", scopes.error.toString());
    } else if (scopes.isPending) {
      return LOADING;
    } else if (scopes.value.length === 0) {
      return /*#__PURE__*/React.createElement("span", null, "(no variables)");
    }

    const scopeSections = scopes.value.map(scope => this._renderScopeSection(scope));
    return /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("div", {
      className: "debugger-expression-value-list"
    }, scopeSections));
  }

}

exports.default = ScopesComponent;

class ScopeComponent extends React.Component {
  render() {
    const {
      variables
    } = this.props;

    if (variables.isError) {
      return /*#__PURE__*/React.createElement("div", null, "Error fetching scope variables ", variables.error.toString());
    } else if (variables.isPending) {
      return LOADING;
    } else if (variables.value.length === 0) {
      return NO_VARIABLES;
    } else {
      return variables.value.map(variable => this._renderVariable(variable));
    }
  }

  _renderVariable(expression) {
    return /*#__PURE__*/React.createElement("div", {
      className: "debugger-expression-value-row debugger-scope",
      key: expression.name
    }, /*#__PURE__*/React.createElement("div", {
      className: "debugger-expression-value-content"
    }, /*#__PURE__*/React.createElement(_ExpressionTreeComponent.ExpressionTreeComponent, {
      expression: expression,
      containerContext: this.props.containerContext
    })));
  }

}

module.exports = exports.default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlNjb3Blc0NvbXBvbmVudC5qcyJdLCJuYW1lcyI6WyJOT19WQVJJQUJMRVMiLCJMT0FESU5HIiwiU2NvcGVzQ29tcG9uZW50IiwiUmVhY3QiLCJDb21wb25lbnQiLCJjb25zdHJ1Y3RvciIsInByb3BzIiwiX2Rpc3Bvc2FibGVzIiwiX2V4cGFuc2lvblN0YXRlcyIsInN0YXRlIiwic2NvcGVzIiwiRXhwZWN0IiwidmFsdWUiLCJleHBhbmRlZFNjb3BlcyIsIlNldCIsIk1hcCIsIlVuaXZlcnNhbERpc3Bvc2FibGUiLCJjb21wb25lbnREaWRNb3VudCIsInZpZXdNb2RlbCIsInNlcnZpY2UiLCJhZGQiLCJPYnNlcnZhYmxlIiwibWVyZ2UiLCJvbkRpZENoYW5nZURlYnVnZ2VyRm9jdXMiLCJiaW5kIiwibWFwIiwib25EaWRDaGFuZ2VFeHByZXNzaW9uQ29udGV4dCIsImRlYm91bmNlVGltZSIsInN0YXJ0V2l0aCIsInN3aXRjaE1hcCIsImZvcmNlUmVmcmVzaCIsIl9nZXRTY29wZXMiLCJzdWJzY3JpYmUiLCJzZXRTdGF0ZSIsImZvY3VzZWRTdGFja0ZyYW1lIiwib2YiLCJyZXN1bHQiLCJmcm9tUHJvbWlzZSIsImdldFNjb3BlcyIsInRoZW4iLCJlcnJvciIsInBlbmRpbmciLCJjb25jYXQiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsImRpc3Bvc2UiLCJfcmVuZGVyU2NvcGVTZWN0aW9uIiwic2NvcGUiLCJleHBhbmRlZCIsIl9pc1Njb3BlRXhwYW5kZWQiLCJTY29wZUJvZHlDb21wb25lbnQiLCJfZ2V0U2NvcGVWYXJpYWJsZXMiLCJ2YXJpYWJsZXMiLCJjb250YWluZXJDb250ZXh0IiwiU2NvcGVDb21wb25lbnQiLCJnZXRJZCIsImlzQ29sbGFwc2VkIiwiX3NldFNjb3BlRXhwYW5kZWQiLCJuYW1lIiwiZ2V0Q2hpbGRyZW4iLCJoYXMiLCJkZWxldGUiLCJyZW5kZXIiLCJpc0Vycm9yIiwidG9TdHJpbmciLCJpc1BlbmRpbmciLCJsZW5ndGgiLCJzY29w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QUFMLENBQVc4QztBQUE5RSxNQURGLENBREYsQ0FERjtBQU9EOztBQXRCc0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IElEZWJ1Z1NlcnZpY2UsIElTY29wZSwgSVZhcmlhYmxlIH0gZnJvbSBcIi4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHsgRXhwZWN0ZWQgfSBmcm9tIFwiQGF0b20taWRlLWNvbW11bml0eS9udWNsaWRlLWNvbW1vbnMvZXhwZWN0ZWRcIlxuXG5pbXBvcnQgeyBiaW5kT2JzZXJ2YWJsZUFzUHJvcHMgfSBmcm9tIFwiQGF0b20taWRlLWNvbW11bml0eS9udWNsaWRlLWNvbW1vbnMtdWkvYmluZE9ic2VydmFibGVBc1Byb3BzXCJcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSBcInJ4anMtY29tcGF0L2J1bmRsZXMvcnhqcy1jb21wYXQudW1kLm1pbi5qc1wiXG5pbXBvcnQgeyBTZWN0aW9uIH0gZnJvbSBcIkBhdG9tLWlkZS1jb21tdW5pdHkvbnVjbGlkZS1jb21tb25zLXVpL1NlY3Rpb25cIlxuaW1wb3J0IFVuaXZlcnNhbERpc3Bvc2FibGUgZnJvbSBcIkBhdG9tLWlkZS1jb21tdW5pdHkvbnVjbGlkZS1jb21tb25zL1VuaXZlcnNhbERpc3Bvc2FibGVcIlxuaW1wb3J0IHsgb2JzZXJ2YWJsZUZyb21TdWJzY3JpYmVGdW5jdGlvbiB9IGZyb20gXCJAYXRvbS1pZGUtY29tbXVuaXR5L251Y2xpZGUtY29tbW9ucy9ldmVudFwiXG5pbXBvcnQgeyBFeHBlY3QgfSBmcm9tIFwiQGF0b20taWRlLWNvbW11bml0eS9udWNsaWRlLWNvbW1vbnMvZXhwZWN0ZWRcIlxuaW1wb3J0IHsgTG9hZGluZ1NwaW5uZXIgfSBmcm9tIFwiQGF0b20taWRlLWNvbW11bml0eS9udWNsaWRlLWNvbW1vbnMtdWkvTG9hZGluZ1NwaW5uZXJcIlxuaW1wb3J0IHsgRXhwcmVzc2lvblRyZWVDb21wb25lbnQgfSBmcm9tIFwiLi9FeHByZXNzaW9uVHJlZUNvbXBvbmVudFwiXG5cbnR5cGUgUHJvcHMgPSB7XG4gICtzZXJ2aWNlOiBJRGVidWdTZXJ2aWNlLFxufVxuXG5jb25zdCBOT19WQVJJQUJMRVMgPSAoXG4gIDxkaXYgY2xhc3NOYW1lPVwiZGVidWdnZXItZXhwcmVzc2lvbi12YWx1ZS1yb3dcIj5cbiAgICA8c3BhbiBjbGFzc05hbWU9XCJkZWJ1Z2dlci1leHByZXNzaW9uLXZhbHVlLWNvbnRlbnRcIj4obm8gdmFyaWFibGVzKTwvc3Bhbj5cbiAgPC9kaXY+XG4pXG5cbmNvbnN0IExPQURJTkcgPSAoXG4gIDxkaXYgY2xhc3NOYW1lPVwiZGVidWdnZXItZXhwcmVzc2lvbi12YWx1ZS1yb3dcIj5cbiAgICA8c3BhbiBjbGFzc05hbWU9XCJkZWJ1Z2dlci1leHByZXNzaW9uLXZhbHVlLWNvbnRlbnRcIj5cbiAgICAgIDxMb2FkaW5nU3Bpbm5lciBzaXplPVwiTUVESVVNXCIgLz5cbiAgICA8L3NwYW4+XG4gIDwvZGl2PlxuKVxuXG50eXBlIFN0YXRlID0ge1xuICBzY29wZXM6IEV4cGVjdGVkPEFycmF5PElTY29wZT4+LFxuICBleHBhbmRlZFNjb3BlczogU2V0PHN0cmluZz4sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjb3Blc0NvbXBvbmVudCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxQcm9wcywgU3RhdGU+IHtcbiAgX2Rpc3Bvc2FibGVzOiBVbml2ZXJzYWxEaXNwb3NhYmxlXG4gIF9leHBhbnNpb25TdGF0ZXM6IE1hcDxzdHJpbmcgLyogZXhwcmVzc2lvbiAqLywgT2JqZWN0IC8qIHVuaXF1ZSByZWZlcmVuY2UgZm9yIGV4cHJlc3Npb24gKi8+XG5cbiAgY29uc3RydWN0b3IocHJvcHM6IFByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHNjb3BlczogRXhwZWN0LnZhbHVlKFtdKSxcbiAgICAgIC8vIFVYOiBMb2NhbCBzY29wZSBuYW1lcyBzaG91bGQgYmUgZXhwYW5kZWQgYnkgZGVmYXVsdC5cbiAgICAgIGV4cGFuZGVkU2NvcGVzOiBuZXcgU2V0KFtcIkxvY2FsXCIsIFwiTG9jYWxzXCJdKSxcbiAgICB9XG4gICAgdGhpcy5fZXhwYW5zaW9uU3RhdGVzID0gbmV3IE1hcCgpXG4gICAgdGhpcy5fZGlzcG9zYWJsZXMgPSBuZXcgVW5pdmVyc2FsRGlzcG9zYWJsZSgpXG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCgpOiB2b2lkIHtcbiAgICBjb25zdCB7IHZpZXdNb2RlbCB9ID0gdGhpcy5wcm9wcy5zZXJ2aWNlXG4gICAgdGhpcy5fZGlzcG9zYWJsZXMuYWRkKFxuICAgICAgT2JzZXJ2YWJsZS5tZXJnZShcbiAgICAgICAgb2JzZXJ2YWJsZUZyb21TdWJzY3JpYmVGdW5jdGlvbih2aWV3TW9kZWwub25EaWRDaGFuZ2VEZWJ1Z2dlckZvY3VzLmJpbmQodmlld01vZGVsKSkubWFwKCgpID0+IGZhbHNlKSxcbiAgICAgICAgb2JzZXJ2YWJsZUZyb21TdWJzY3JpYmVGdW5jdGlvbih2aWV3TW9kZWwub25EaWRDaGFuZ2VFeHByZXNzaW9uQ29udGV4dC5iaW5kKHZpZXdNb2RlbCkpLm1hcCgoKSA9PiB0cnVlKVxuICAgICAgKVxuICAgICAgICAuZGVib3VuY2VUaW1lKDEwMClcbiAgICAgICAgLnN0YXJ0V2l0aChmYWxzZSlcbiAgICAgICAgLnN3aXRjaE1hcCgoZm9yY2VSZWZyZXNoOiBib29sZWFuKSA9PiB0aGlzLl9nZXRTY29wZXMoZm9yY2VSZWZyZXNoKSlcbiAgICAgICAgLnN1YnNjcmliZSgoc2NvcGVzKSA9PiB7XG4gICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IHNjb3BlcyB9KVxuICAgICAgICB9KVxuICAgIClcbiAgfVxuXG4gIF9nZXRTY29wZXMoZm9yY2VSZWZyZXNoOiBib29sZWFuKTogT2JzZXJ2YWJsZTxFeHBlY3RlZDxBcnJheTxJU2NvcGU+Pj4ge1xuICAgIGNvbnN0IHsgZm9jdXNlZFN0YWNrRnJhbWUgfSA9IHRoaXMucHJvcHMuc2VydmljZS52aWV3TW9kZWxcbiAgICBpZiAoZm9jdXNlZFN0YWNrRnJhbWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIE9ic2VydmFibGUub2YoRXhwZWN0LnZhbHVlKFtdKSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgcmVmcmVzaGluZyBleHBsaWNpdGx5LCBkb24ndCBzdGFydCB3aXRoIHBlbmRpbmcgYmVjYXVzZVxuICAgICAgLy8gdGhlcmUncyBubyByZWFzb24gdG8gc2hvdyBhIHNwaW5uZXIgaW4gYW4gYWxyZWFkeS1wb3B1bGF0ZWRcbiAgICAgIC8vIHNjb3BlcyB0cmVlLlxuICAgICAgY29uc3QgcmVzdWx0ID0gT2JzZXJ2YWJsZS5mcm9tUHJvbWlzZShcbiAgICAgICAgZm9jdXNlZFN0YWNrRnJhbWUuZ2V0U2NvcGVzKGZvcmNlUmVmcmVzaCkudGhlbihcbiAgICAgICAgICAoc2NvcGVzKSA9PiBFeHBlY3QudmFsdWUoc2NvcGVzKSxcbiAgICAgICAgICAoZXJyb3IpID0+IEV4cGVjdC5lcnJvcihlcnJvcilcbiAgICAgICAgKVxuICAgICAgKVxuICAgICAgcmV0dXJuIGZvcmNlUmVmcmVzaCA/IHJlc3VsdCA6IE9ic2VydmFibGUub2YoRXhwZWN0LnBlbmRpbmcoKSkuY29uY2F0KHJlc3VsdClcbiAgICB9XG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpOiB2b2lkIHtcbiAgICB0aGlzLl9kaXNwb3NhYmxlcy5kaXNwb3NlKClcbiAgfVxuXG4gIF9yZW5kZXJTY29wZVNlY3Rpb24oc2NvcGU6IElTY29wZSk6ID9SZWFjdC5FbGVtZW50PGFueT4ge1xuICAgIC8vIE5vbi1sb2NhbCBzY29wZXMgc2hvdWxkIGJlIGNvbGxhcHNlZCBieSBkZWZhdWx0IHNpbmNlIHVzZXJzIHR5cGljYWxseSBjYXJlIGxlc3MgYWJvdXQgdGhlbS5cbiAgICBjb25zdCBleHBhbmRlZCA9IHRoaXMuX2lzU2NvcGVFeHBhbmRlZChzY29wZSlcbiAgICBjb25zdCBTY29wZUJvZHlDb21wb25lbnQgPSBleHBhbmRlZFxuICAgICAgPyBiaW5kT2JzZXJ2YWJsZUFzUHJvcHMoXG4gICAgICAgICAgdGhpcy5fZ2V0U2NvcGVWYXJpYWJsZXMoc2NvcGUpLm1hcCgodmFyaWFibGVzKSA9PiAoe1xuICAgICAgICAgICAgdmFyaWFibGVzLFxuICAgICAgICAgICAgY29udGFpbmVyQ29udGV4dDogdGhpcyxcbiAgICAgICAgICB9KSksXG4gICAgICAgICAgU2NvcGVDb21wb25lbnRcbiAgICAgICAgKVxuICAgICAgOiAoKSA9PiBudWxsXG5cbiAgICByZXR1cm4gKFxuICAgICAgPFNlY3Rpb25cbiAgICAgICAga2V5PXtzY29wZS5nZXRJZCgpfVxuICAgICAgICBjb2xsYXBzYWJsZT17dHJ1ZX1cbiAgICAgICAgY29sbGFwc2VkPXshZXhwYW5kZWR9XG4gICAgICAgIG9uQ2hhbmdlPXsoaXNDb2xsYXBzZWQpID0+IHRoaXMuX3NldFNjb3BlRXhwYW5kZWQoc2NvcGUsICFpc0NvbGxhcHNlZCl9XG4gICAgICAgIGhlYWRsaW5lPXtzY29wZS5uYW1lfVxuICAgICAgICBzaXplPVwic21hbGxcIlxuICAgICAgPlxuICAgICAgICA8U2NvcGVCb2R5Q29tcG9uZW50IC8+XG4gICAgICA8L1NlY3Rpb24+XG4gICAgKVxuICB9XG5cbiAgX2dldFNjb3BlVmFyaWFibGVzKHNjb3BlOiBJU2NvcGUpOiBPYnNlcnZhYmxlPEV4cGVjdGVkPEFycmF5PElWYXJpYWJsZT4+PiB7XG4gICAgcmV0dXJuIE9ic2VydmFibGUub2YoRXhwZWN0LnBlbmRpbmcoKSkuY29uY2F0KFxuICAgICAgT2JzZXJ2YWJsZS5mcm9tUHJvbWlzZShcbiAgICAgICAgc2NvcGUuZ2V0Q2hpbGRyZW4oKS50aGVuKFxuICAgICAgICAgICh2YXJpYWJsZXMpID0+IEV4cGVjdC52YWx1ZSh2YXJpYWJsZXMpLFxuICAgICAgICAgIChlcnJvcikgPT4gRXhwZWN0LmVycm9yKGVycm9yKVxuICAgICAgICApXG4gICAgICApXG4gICAgKVxuICB9XG5cbiAgX2lzU2NvcGVFeHBhbmRlZChzY29wZTogSVNjb3BlKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuZXhwYW5kZWRTY29wZXMuaGFzKHNjb3BlLm5hbWUpXG4gIH1cblxuICBfc2V0U2NvcGVFeHBhbmRlZChzY29wZTogSVNjb3BlLCBleHBhbmRlZDogYm9vbGVhbik6IHZvaWQge1xuICAgIGlmIChleHBhbmRlZCA9PT0gdGhpcy5zdGF0ZS5leHBhbmRlZFNjb3Blcy5oYXMoc2NvcGUubmFtZSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyBUT0RPOiAod2Jpbm5zc21pdGgpIFQzMDc3MTQzNSB0aGlzIHNldFN0YXRlIGRlcGVuZHMgb24gY3VycmVudCBzdGF0ZVxuICAgIC8vIGFuZCBzaG91bGQgdXNlIGFuIHVwZGF0ZXIgZnVuY3Rpb24gcmF0aGVyIHRoYW4gYW4gb2JqZWN0XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L25vLWFjY2Vzcy1zdGF0ZS1pbi1zZXRzdGF0ZVxuICAgIGNvbnN0IGV4cGFuZGVkU2NvcGVzID0gbmV3IFNldCh0aGlzLnN0YXRlLmV4cGFuZGVkU2NvcGVzKVxuICAgIGlmIChleHBhbmRlZCkge1xuICAgICAgZXhwYW5kZWRTY29wZXMuYWRkKHNjb3BlLm5hbWUpXG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cGFuZGVkU2NvcGVzLmRlbGV0ZShzY29wZS5uYW1lKVxuICAgIH1cbiAgICB0aGlzLnNldFN0YXRlKHsgZXhwYW5kZWRTY29wZXMgfSlcbiAgfVxuXG4gIHJlbmRlcigpOiBSZWFjdC5Ob2RlIHtcbiAgICBjb25zdCB7IHNjb3BlcyB9ID0gdGhpcy5zdGF0ZVxuICAgIGlmIChzY29wZXMuaXNFcnJvcikge1xuICAgICAgcmV0dXJuIDxzcGFuPkVycm9yIGZldGNoaW5nIHNjb3Blczoge3Njb3Blcy5lcnJvci50b1N0cmluZygpfTwvc3Bhbj5cbiAgICB9IGVsc2UgaWYgKHNjb3Blcy5pc1BlbmRpbmcpIHtcbiAgICAgIHJldHVybiBMT0FESU5HXG4gICAgfSBlbHNlIGlmIChzY29wZXMudmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gPHNwYW4+KG5vIHZhcmlhYmxlcyk8L3NwYW4+XG4gICAgfVxuICAgIGNvbnN0IHNjb3BlU2VjdGlvbnMgPSBzY29wZXMudmFsdWUubWFwKChzY29wZSkgPT4gdGhpcy5fcmVuZGVyU2NvcGVTZWN0aW9uKHNjb3BlKSlcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJkZWJ1Z2dlci1leHByZXNzaW9uLXZhbHVlLWxpc3RcIj57c2NvcGVTZWN0aW9uc308L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxufVxuXG50eXBlIFNjb3BlUHJvcHMgPSB7XG4gIHZhcmlhYmxlczogRXhwZWN0ZWQ8QXJyYXk8SVZhcmlhYmxlPj4sXG4gIGNvbnRhaW5lckNvbnRleHQ6IE9iamVjdCxcbn1cblxuY2xhc3MgU2NvcGVDb21wb25lbnQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8U2NvcGVQcm9wcz4ge1xuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyB2YXJpYWJsZXMgfSA9IHRoaXMucHJvcHNcbiAgICBpZiAodmFyaWFibGVzLmlzRXJyb3IpIHtcbiAgICAgIHJldHVybiA8ZGl2PkVycm9yIGZldGNoaW5nIHNjb3BlIHZhcmlhYmxlcyB7dmFyaWFibGVzLmVycm9yLnRvU3RyaW5nKCl9PC9kaXY+XG4gICAgfSBlbHNlIGlmICh2YXJpYWJsZXMuaXNQZW5kaW5nKSB7XG4gICAgICByZXR1cm4gTE9BRElOR1xuICAgIH0gZWxzZSBpZiAodmFyaWFibGVzLnZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIE5PX1ZBUklBQkxFU1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmFyaWFibGVzLnZhbHVlLm1hcCgodmFyaWFibGUpID0+IHRoaXMuX3JlbmRlclZhcmlhYmxlKHZhcmlhYmxlKSlcbiAgICB9XG4gIH1cblxuICBfcmVuZGVyVmFyaWFibGUoZXhwcmVzc2lvbjogSVZhcmlhYmxlKTogP1JlYWN0LkVsZW1lbnQ8YW55PiB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZGVidWdnZXItZXhwcmVzc2lvbi12YWx1ZS1yb3cgZGVidWdnZXItc2NvcGVcIiBrZXk9e2V4cHJlc3Npb24ubmFtZX0+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZGVidWdnZXItZXhwcmVzc2lvbi12YWx1ZS1jb250ZW50XCI+XG4gICAgICAgICAgPEV4cHJlc3Npb25UcmVlQ29tcG9uZW50IGV4cHJlc3Npb249e2V4cHJlc3Npb259IGNvbnRhaW5lckNvbnRleHQ9e3RoaXMucHJvcHMuY29udGFpbmVyQ29udGV4dH0gLz5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbn1cbiJdfQ==